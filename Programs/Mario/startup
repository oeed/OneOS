local runningLocation = shell.getRunningProgram()
runningLocation = runningLocation:sub(1, #runningLocation-7) --this should be changed!

if OneOS then
	--running under OneOS
	OneOS.ToolBarColour = colours.grey
	OneOS.ToolBarTextColour = colours.white
end

colours.transparent = -1
colors.transparent = -1

--TODO: make and insert logo
--PikLogo = [[]]


--APIS--

--This is my drawing API, is is pretty much identical to what drives OneOS, PearOS, etc.
local _w, _h = term.getSize()

local round = function(num, idp)
	local mult = 10^(idp or 0)
	return math.floor(num * mult + 0.5) / mult
end

local hexnums = { [10] = "a", [11] = "b", [12] = "c", [13] = "d", [14] = "e" , [15] = "f" }

Drawing = {
	
	Screen = {
		Width = _w,
		Height = _h
	},

	DrawCharacters = function (x, y, characters, textColour,bgColour)
		Drawing.WriteStringToBuffer(x, y, characters, textColour, bgColour)
	end,
	
	DrawBlankArea = function (x, y, w, h, colour)
		Drawing.DrawArea (x, y, w, h, " ", 1, colour)
	end,

	DrawArea = function (x, y, w, h, character, textColour, bgColour)
		--width must be greater than 1, other wise we get a stack overflow
		if w < 0 then
			w = w * -1
		elseif w == 0 then
			w = 1
		end

		for ix = 1, w do
			local currX = x + ix - 1
			for iy = 1, h do
				local currY = y + iy - 1
				Drawing.WriteToBuffer(currX, currY, character, textColour, bgColour)
			end
		end
	end,

	DrawImage = function(_x,_y,tImage, w, h)
		if tImage then
			for y = 1, h do
				if not tImage[y] then
					break
				end
				for x = 1, w do
					if not tImage[y][x] then
						break
					end
					local bgColour = tImage[y][x]
		            local textColour = tImage.textcol[y][x] or colours.white
		            local char = tImage.text[y][x]
		            Drawing.WriteToBuffer(x+_x-1, y+_y-1, char, textColour, bgColour)
				end
			end
		elseif w and h then
			Drawing.DrawBlankArea(x, y, w, h, colours.green)
		end
	end,
	--using .nft
	LoadImage = function(path)
		local image = {
			text = {},
			textcol = {}
		}
		if fs.exists(path) then
	        local file = io.open(path, "r")
	        local sLine = file:read()
	        local num = 1
	        while sLine do  
	                table.insert(image, num, {})
	                table.insert(image.text, num, {})
	                table.insert(image.textcol, num, {})
	                                            
	                --As we're no longer 1-1, we keep track of what index to write to
	                local writeIndex = 1
	                --Tells us if we've hit a 30 or 31 (BG and FG respectively)- next char specifies the curr colour
	                local bgNext, fgNext = false, false
	                --The current background and foreground colours
	                local currBG, currFG = nil,nil
	                term.setCursorPos(1,1)
	                for i=1,#sLine do
	                        local nextChar = string.sub(sLine, i, i)
	                        if nextChar:byte() == 30 then
	                                bgNext = true
	                        elseif nextChar:byte() == 31 then
	                                fgNext = true
	                        elseif bgNext then
	                                currBG = Drawing.GetColourOf(nextChar)
	                                bgNext = false
	                        elseif fgNext then
	                                currFG = Drawing.GetColourOf(nextChar)
	                                fgNext = false
	                        else
	                                if nextChar ~= " " and currFG == nil then
	                                        currFG = colours.white
	                                end
	                                image[num][writeIndex] = currBG
	                                image.textcol[num][writeIndex] = currFG
	                                image.text[num][writeIndex] = nextChar
	                                writeIndex = writeIndex + 1
	                        end
	                end
	                num = num+1
	                sLine = file:read()
	        end
	        file:close()
		end
	 	return image
	end,

	DrawCharactersCenter = function(x, y, w, h, characters, textColour,bgColour)
		w = w or Drawing.Screen.Width
		h = h or Drawing.Screen.Height
		x = x or 0
		y = y or 0
		x = math.ceil((w - #characters) / 2) + x
		y = math.floor(h / 2) + y

		Drawing.DrawCharacters(x, y, characters, textColour, bgColour)
	end,

	GetHexOf = function(colour)
	    if colour == colours.transparent or not colour or not tonumber(colour) then
	            return " "
	    end
	    local value = math.log(colour)/math.log(2)
	    if value > 9 then
	            value = hexnums[value]
	    end
	    return value
	end,

	GetColourOf = function (hex)
        local value = tonumber(hex, 16)
        if not value then return nil end
        value = math.pow(2,value)
        return value
	end,

	Clear = function (_colour)
		_colour = _colour or colours.black
		Drawing.ClearBuffer()
		Drawing.DrawBlankArea(1, 1, Drawing.Screen.Width, Drawing.Screen.Height, _colour)
	end,

	Buffer = {},
	BackBuffer = {},

	DrawBuffer = function()
		for y,row in pairs(Drawing.Buffer) do
			for x,pixel in pairs(row) do
				local shouldDraw = true
				local hasBackBuffer = true
				if Drawing.BackBuffer[y] == nil or Drawing.BackBuffer[y][x] == nil or #Drawing.BackBuffer[y][x] ~= 3 then
					hasBackBuffer = false
				end
				if hasBackBuffer and Drawing.BackBuffer[y][x][1] == Drawing.Buffer[y][x][1] and Drawing.BackBuffer[y][x][2] == Drawing.Buffer[y][x][2] and Drawing.BackBuffer[y][x][3] == Drawing.Buffer[y][x][3] then
					shouldDraw = false
				end
				if shouldDraw then
					term.setBackgroundColour(pixel[3])
					term.setTextColour(pixel[2])
					term.setCursorPos(x, y)
					term.write(pixel[1])
				end
			end
		end
		Drawing.BackBuffer = Drawing.Buffer
		Drawing.Buffer = {}
		term.setCursorPos(1,1)
	end,

	ClearBuffer = function()
		Drawing.Buffer = {}
	end,

	Offset = {
		X = 0,
		Y = 0,
	},

	SetOffset = function(x, y)
		Drawing.Offset.X = x
		Drawing.Offset.Y = y
	end,

	ClearOffset = function()
		Drawing.Offset = {
			X = 0,
			Y = 0,
		}
	end,

	WriteStringToBuffer = function (x, y, characters, textColour,bgColour)
		for i = 1, #characters do
   			local character = characters:sub(i,i)
   			Drawing.WriteToBuffer(x + i - 1, y, character, textColour, bgColour)
		end
	end,

	WriteToBuffer = function(x, y, character, textColour,bgColour)
		x = round(x)
		y = round(y)
		if bgColour == colours.transparent then
			x = x + Drawing.Offset.X
			y = y + Drawing.Offset.Y
			Drawing.Buffer[y] = Drawing.Buffer[y] or {}
			Drawing.Buffer[y][x] = Drawing.Buffer[y][x] or {"", colours.white, colours.black}
			Drawing.Buffer[y][x][1] = character
			Drawing.Buffer[y][x][2] = textColour
		else
			x = x + Drawing.Offset.X
			y = y + Drawing.Offset.Y
			Drawing.Buffer[y] = Drawing.Buffer[y] or {}
			Drawing.Buffer[y][x] = {character, textColour, bgColour}
		end
	end,
}

Parameters = {
	Gravity = 2, --in pixels / seconds
	AirFriction = 10, --in pixels / seconds, this is only counted in horizontal velocity
	SurfaceFriction = 40,
}

Events = {}

Directions = {
	Up = 'up',
	Left = 'left',
	Down = 'down',
	Right = 'right'
}

Sprite = {
	X = 1,
	Y = 1,
	Width = 0,
	Height = 0,
	Background = colours.white,
	Parent = nil,
	Tag = nil,
	Velocity = vector.new(0,0,0),

	Draw = function(self, delta)
		self:CalculateLocation(delta)

		local bg = self.Background
		if type(bg) == 'function' then
			bg = bg()
		end

		local pos = GetAbsolutePosition(self)
		if type(bg) == 'table' then
			Drawing.DrawImage(pos.X, pos.Y, bg, self.Width, self.Height)
		else
			Drawing.DrawBlankArea(pos.X, pos.Y, self.Width, self.Height, bg)
		end
	end,

	CalculateLocation = function(self, delta)
		print(delta)
		--First, update the velocity
		--if self.Velocity.y ~= 0 then
		self.Velocity.y = self.Velocity.y - (Parameters.Gravity * delta)

		local friction = Parameters.AirFriction

		if self.Y == 13 then
			friction = Parameters.SurfaceFriction
		end

		if self.Velocity.x < 0 then
			--friction = -1 * friction
		end

		if friction > self.Velocity.x then
			friction = self.Velocity.x
		end

		self.Velocity.x = self.Velocity.x - (friction * delta)


		self.Y = self.Y - self.Velocity.y
		self.X = self.X + self.Velocity.x



		if self.Y > 13 then
			self.Y = 13
			self.Velocity.y = 0
		end

		if self.Velocity.x < 0.15 and self.Velocity.x > -0.15 then
			self.Velocity.x = 0
			self.X = round(self.X)
		end

		print(self.Velocity)
		print(self.X ..', '..self.Y)

	end,

	Initialise = function(self, x, y, width, height, background, parent, tag)
		local new = {}    -- the new instance
		setmetatable( new, {__index = self} )
		height = height or 1
		new.Width = width or #text + 2
		new.Height = height
		new.Y = y
		new.X = x
		if type(background) == 'string' then
			background = Drawing.LoadImage(runningLocation .. 'Sprites/' .. background)
		end
		new.Background = background or colours.white
		new.Parent = parent
		new.Tag = tag
		return new
	end,

	Register = function(self)
		for i, sprite in ipairs(Sprites) do
			if sprite == self then
				return
			end
		end

		table.insert(Sprites, self)
		return self
	end,

	Unregister = function(self)
		for i, sprite in ipairs(Sprites) do
			if sprite == self then
				Sprites[i] = nil
				return
			end
		end
	end
}

Map = {
	
}

function SpriteFromTag(tag)
	for i, sprite in ipairs(Sprites) do
		if sprite.Tag == tag then
			return sprite
		end
	end
end

Sprites = {}

local lastDraw = os.clock()
function Draw()
	local delta = os.clock() - lastDraw
	Drawing.Clear(colours.lightBlue)
	for i, sprite in ipairs(Sprites) do
		sprite:Draw(delta)
	end
	Drawing.DrawBuffer()
	os.startTimer(0.1)
	lastDraw = os.clock()
end

function Timer(timer)
end

function Initialise()
	EventRegister('mouse_click', TryClick)
	EventRegister('mouse_drag', TryClick)
	EventRegister('mouse_scroll', Scroll)
	EventRegister('key', HandleKey)
	EventRegister('char', HandleKey)
	EventRegister('timer', Draw)


	term.setBackgroundColour(colours.lightBlue)
	term.clear()

	Sprite:Initialise(25, 2, 1, 2, 'player.nft', nil, 'Player'):Register()

	Draw()

	os.startTimer(0.1)

	EventHandler()
end

function GetAbsolutePosition(object)
	local obj = object
	local i = 0
	local x = 1
	local y = 1
	while true do
		x = x + obj.X - 1
		y = y + obj.Y - 1

		if not obj.Parent then
			return {X = x, Y = y}
		end

		obj = obj.Parent

		if i > 32 then
			return {X = 1, Y = 1}
		end

		i = i + 1
	end
end

function HandleKey(...)
	local args = {...}
	local event = args[1]
	local keychar = args[2]
	if event == 'key' then
		local playerSprite = SpriteFromTag('Player')
		if not playerSprite then
			return
		end

		if keychar == keys.up then
			if playerSprite.Y >= 13 then
				playerSprite.Velocity.y = 1
			end
		elseif keychar == keys.down then
			playerSprite.Y = playerSprite.Y + 1
		elseif keychar == keys.left then
			playerSprite.Velocity.x = -0.5
		elseif keychar == keys.right then
			playerSprite.Velocity.x = 0.5
		end
		--Draw()
	end
end

function CheckKeyboardShortcut(key)
	local shortcuts = {}

	if key == keys.leftCtrl then
		Current.ControlPressedTimer = os.startTimer(0.5)
		return
	end
	if Current.ControlPressedTimer then
		shortcuts[keys.n] = function() DisplayNewDocumentWindow() end
		shortcuts[keys.o] = function() DisplayOpenDocumentWindow() end
		shortcuts[keys.s] = function() Current.Artboard:Save() end
		shortcuts[keys.z] = function()  end
		shortcuts[keys.y] = function()  end
		shortcuts[keys.x] = function()  end
		shortcuts[keys.c] = function()  end
		shortcuts[keys.v] = function()  end
		shortcuts[keys.r] = function() ResizeDocument() end
		shortcuts[keys.l] = function() MakeNewLayer() end
	end

	shortcuts[keys.delete] = function()  end
	shortcuts[keys.tab] = function()  end

	shortcuts[keys.e] = function() SetTool(Tools.Eraser) end
	shortcuts[keys.p] = function() SetTool(Tools.Pencil) end

	if shortcuts[key] then
		shortcuts[key]()
		return true
	else
		return false
	end
end

--[[
	Check if the given object falls under the click coordinates
]]--
function CheckClick(object, x, y)
	if object.X <= x and object.Y <= y and object.X + object.Width > x and object.Y + object.Height > y then
		return true
	end
end

--[[
	Attempt to clicka given object
]]--
function DoClick(object, side, x, y)
	if object and CheckClick(object, x, y) then
		return object:Click(side, x - object.X + 1, y - object.Y + 1)
	end	
end

--[[
	Try to click at the given coordinates
]]--
function TryClick(event, side, x, y)
	--[[
for i, object in ipairs(interfaceElements) do
		if DoClick(object, side, x, y) then
			Draw()
			return
		end		
	end
]]--
	Draw()
end

--[[
	Registers functions to run on certain events
]]--
function EventRegister(event, func)
	if not Events[event] then
		Events[event] = {}
	end

	table.insert(Events[event], func)
end

--[[
	The main loop event handler, runs registered event functinos
]]--
function EventHandler()
	while true do
		local event, arg1, arg2, arg3, arg4 = os.pullEvent()
		if Events[event] then
			for i, e in ipairs(Events[event]) do
				e(event, arg1, arg2, arg3, arg4)
			end
		end
	end
end

Initialise()
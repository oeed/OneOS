	local continue = true

	function GetYForLevel(level)
		if level == 1 then
			return Current.HomeY-2, Current.HomeY-10
		elseif level == 2 then
			return Current.HomeY-10, Current.HomeY-20
		elseif level == 3 then
			return 45, 32
		elseif level == 4 then
			return 24, 8
		end
	end

	function Start()
		Turtle.SetHome()	

		if Current.Miner.useChest then
			local chestSlot = 1
			local chestCount = 1
			for i = 1, 16 do
				local count = Turtle.ItemCount(i)
				if count > 0 then
					chestSlot = i
					chestCount = count
					break
				end
			end

			Turtle.SetState('Placing chest(s)')
			Turtle.TurnLeft(2)
			Turtle.Dig()
			Turtle.Place(chestSlot)
			if chestCount == 2 then
				Turtle.TurnLeft()
				Turtle.DigMoveForward()
				Turtle.TurnRight()
				Turtle.Dig()
				Turtle.Place(chestSlot)
				Turtle.TurnRight()
				Turtle.Forward()
				Turtle.TurnRight()
			else
				Turtle.TurnRight(2)
			end
		end

		Turtle.SetState('Moving down to level...')
		--Turtle.DigMoveDown(Current.HomeY- GetTopForLevel(Current.Miner.level))
		Turtle.SetState('Mining layer...')
		

		--ReturnItems()


		--MineLayer(3)

		continue = true
		local layersMined = 0
		local levelStart, levelEnd = GetYForLevel(Current.Miner.level)
		local levels = levelStart - levelEnd
		print('---')
		print(levelStart)
		print(levelEnd)
		print(levels)
		while continue do
			if Turtle.FuelLevel() <= 0 then
				print('Needs refuel!')
				Turtle.SetState('Fuel empty')
				Turtle.Refuel()
				sleep(1)
			else

				Turtle.DigMoveDown(Current.HomeY - levelStart + layersMined)
				local _ = MineLayer(4, 4)--levels-layersMined
				print('back')
				if _ and _ > 0 then
					layersMined = _
					print('continue')
				elseif not _ then
					print('not continue')
					continue = false
				end
				print('return i')
				ReturnItems()
			end
		end

	end

	function CheckSafeReturn()
			local distance = 0

			distance = distance + math.abs(Turtle.RelativePosition.X)
			distance = distance + math.abs(Turtle.RelativePosition.Y)
			distance = distance + math.abs(Turtle.RelativePosition.Z)
			print('distance')
			print(math.abs(Turtle.RelativePosition.X))
			print(math.abs(Turtle.RelativePosition.Y))
			print(math.abs(Turtle.RelativePosition.Z))
			print('fuel check')
			print(distance)
			print(Turtle.FuelLevel() - 1)
			if distance > (Turtle.FuelLevel() - 2) then
				print('no 1')
				Turtle.Refuel(1)
				if distance > (Turtle.FuelLevel() - 2) then
					print('no 2aw')
					return true
				end
			end
	end

	function CheckInventoryFull()
		local full = true
		for i = 1, 16 do
			if Turtle.ItemCount(i) == 0 then
				full = false
			end
		end

		if full then
			ReturnItems()
			return true
		end
		--[[
local _,spaceLeft = turtle.suck()
		if not _ and spaceLeft == 'No space for items' then
			ReturnItems()
			return true
		end
]]--
	end

	function ReturnItems()
		isReturning = true
		Turtle.GoHome()
		if Current.Miner.useChest then
			Turtle.RotateTo(2)
			if Turtle.Detect() then
				Turtle.DropAll()
			else
				continue = false
			end
			Turtle.RotateTo(0)
		else
			continue = false
		end
		isReturning = false
	end


	function MineLayer(w, h)
		w = w or 1
		h = h or 1
		w = w - w%2
		h = h - h%2
		for z = 1, w do
			for y = 1, h do
				for x = 1, 2 do
					if CheckInventoryFull() or CheckSafeReturn() then
						return z, y-1
					else
						Turtle.DigMoveForward(1)	
					end
				end

				if z%2 == 1 then
					Turtle.DigMoveDown(1)
				else
					Turtle.DigMoveUp(1)
				end
				
				Turtle.TurnLeft(2)
			end
			Turtle.DigMoveUp(1)
			Turtle.RotateTo(0)
			Turtle.TurnRight()
			Turtle.DigMoveForward()
			Turtle.TurnLeft()
		end
		return false
	end
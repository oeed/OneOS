if OneOS then
	--running under OneOS
	OneOS.ToolBarColour = colours.grey
	OneOS.ToolBarTextColour = colours.white
end

local _w, _h = term.getSize()

local round = function(num, idp)
	local mult = 10^(idp or 0)
	return math.floor(num * mult + 0.5) / mult
end

UIColours = {
	Toolbar = colours.grey,
	ToolbarText = colours.lightGrey,
	ToolbarSelected = colours.lightBlue,
	ControlText = colours.white,
	ToolbarItemTitle = colours.black,
	Background = colours.lightGrey,
	MenuBackground = colours.white,
	MenuText = colours.black,
	MenuSeparatorText = colours.grey,
	MenuDisabledText = colours.lightGrey,
	Shadow = colours.grey,
	TransparentBackgroundOne = colours.white,
	TransparentBackgroundTwo = colours.lightGrey,
	MenuBarActive = colours.white
}


Clipboard = {
	Content = nil,
	Type = nil,
	IsCut = false,

	Empty = function()
		Clipboard.Content = nil
		Clipboard.Type = nil
		Clipboard.IsCut = false
	end,

	isEmpty = function()
		return Clipboard.Content == nil
	end,

	Copy = function(content, _type)
		Clipboard.Content = content
		Clipboard.Type = _type or 'generic'
		Clipboard.IsCut = false
	end,

	Cut = function(content, _type)
		Clipboard.Content = content
		Clipboard.Type = _type or 'generic'
		Clipboard.IsCut = true
	end,

	Paste = function()
		local c, t = Clipboard.Content, Clipboard.Type
		if Clipboard.IsCut then
			Clipboard.Empty()
		end
		return c, t
	end
}

if OneOS and OneOS.Clipboard then
	Clipboard = OneOS.Clipboard
end

Drawing = {
	
	Screen = {
		Width = _w,
		Height = _h
	},

	DrawCharacters = function (x, y, characters, textColour,bgColour)
		Drawing.WriteStringToBuffer(x, y, characters, textColour, bgColour)
	end,
	
	DrawBlankArea = function (x, y, w, h, colour)
		Drawing.DrawArea (x, y, w, h, " ", 1, colour)
	end,

	DrawArea = function (x, y, w, h, character, textColour, bgColour)
		--width must be greater than 1, other wise we get a stack overflow
		if w < 0 then
			w = w * -1
		elseif w == 0 then
			w = 1
		end

		for ix = 1, w do
			local currX = x + ix - 1
			for iy = 1, h do
				local currY = y + iy - 1
				Drawing.WriteToBuffer(currX, currY, character, textColour, bgColour)
			end
		end
	end,

	DrawImage = function(_x,_y,tImage, w, h)
		if tImage then
			for y = 1, h do
				if not tImage[y] then
					break
				end
				for x = 1, w do
					if not tImage[y][x] then
						break
					end
					local bgColour = tImage[y][x]
		            local textColour = tImage.textcol[y][x] or colours.white
		            local char = tImage.text[y][x]
		            Drawing.WriteToBuffer(x+_x-1, y+_y-1, char, textColour, bgColour)
				end
			end
		elseif w and h then
			Drawing.DrawBlankArea(x, y, w, h, colours.green)
		end
	end,
	--using .nft
	LoadImage = function(path)
		local image = {
			text = {},
			textcol = {}
		}
		local _fs = fs
		if OneOS then
			_fs = OneOS.FS
		end
		if _fs.exists(path) then
			local _open = io.open
			if OneOS then
				_open = OneOS.IO.open
			end
	        local file = _open(path, "r")
	        local sLine = file:read()
	        local num = 1
	        while sLine do  
	                table.insert(image, num, {})
	                table.insert(image.text, num, {})
	                table.insert(image.textcol, num, {})
	                                            
	                --As we're no longer 1-1, we keep track of what index to write to
	                local writeIndex = 1
	                --Tells us if we've hit a 30 or 31 (BG and FG respectively)- next char specifies the curr colour
	                local bgNext, fgNext = false, false
	                --The current background and foreground colours
	                local currBG, currFG = nil,nil
	                for i=1,#sLine do
	                        local nextChar = string.sub(sLine, i, i)
	                        if nextChar:byte() == 30 then
                                bgNext = true
	                        elseif nextChar:byte() == 31 then
                                fgNext = true
	                        elseif bgNext then
                                currBG = Drawing.GetColour(nextChar)
                                bgNext = false
	                        elseif fgNext then
                                currFG = Drawing.GetColour(nextChar)
                                fgNext = false
	                        else
                                if nextChar ~= " " and currFG == nil then
                                       currFG = colours.white
                                end
                                image[num][writeIndex] = currBG
                                image.textcol[num][writeIndex] = currFG
                                image.text[num][writeIndex] = nextChar
                                writeIndex = writeIndex + 1
	                        end
	                end
	                num = num+1
	                sLine = file:read()
	        end
	        file:close()
		end
	 	return image
	end,

	DrawCharactersCenter = function(x, y, w, h, characters, textColour,bgColour)
		w = w or Drawing.Screen.Width
		h = h or Drawing.Screen.Height
		x = x or 0
		y = y or 0
		x = math.ceil((w - #characters) / 2) + x
		y = math.floor(h / 2) + y

		Drawing.DrawCharacters(x, y, characters, textColour, bgColour)
	end,

	GetColour = function(hex)
		if hex == ' ' then
			return colours.transparent
		end
	    local value = tonumber(hex, 16)
	    if not value then return nil end
	    value = math.pow(2,value)
	    return value
	end,

	Clear = function (_colour)
		_colour = _colour or colours.black
		Drawing.ClearBuffer()
		Drawing.DrawBlankArea(1, 1, Drawing.Screen.Width, Drawing.Screen.Height, _colour)
	end,

	Buffer = {},
	BackBuffer = {},

	DrawBuffer = function()
		for y,row in pairs(Drawing.Buffer) do
			for x,pixel in pairs(row) do
				local shouldDraw = true
				local hasBackBuffer = true
				if Drawing.BackBuffer[y] == nil or Drawing.BackBuffer[y][x] == nil or #Drawing.BackBuffer[y][x] ~= 3 then
					hasBackBuffer = false
				end
				if hasBackBuffer and Drawing.BackBuffer[y][x][1] == Drawing.Buffer[y][x][1] and Drawing.BackBuffer[y][x][2] == Drawing.Buffer[y][x][2] and Drawing.BackBuffer[y][x][3] == Drawing.Buffer[y][x][3] then
					shouldDraw = false
				end
				if shouldDraw then
					term.setBackgroundColour(pixel[3])
					term.setTextColour(pixel[2])
					term.setCursorPos(x, y)
					term.write(pixel[1])
				end
			end
		end
		Drawing.BackBuffer = Drawing.Buffer
		Drawing.Buffer = {}
		term.setCursorPos(1,1)
	end,

	ClearBuffer = function()
		Drawing.Buffer = {}
	end,

	WriteStringToBuffer = function (x, y, characters, textColour,bgColour)
		for i = 1, #characters do
   			local character = characters:sub(i,i)
   			Drawing.WriteToBuffer(x + i - 1, y, character, textColour, bgColour)
		end
	end,

	WriteToBuffer = function(x, y, character, textColour,bgColour)
		x = round(x)
		y = round(y)
		if bgColour == colours.transparent then
			Drawing.Buffer[y] = Drawing.Buffer[y] or {}
			Drawing.Buffer[y][x] = Drawing.Buffer[y][x] or {"", colours.white, colours.black}
			Drawing.Buffer[y][x][1] = character
			Drawing.Buffer[y][x][2] = textColour
		else
			Drawing.Buffer[y] = Drawing.Buffer[y] or {}
			Drawing.Buffer[y][x] = {character, textColour, bgColour}
		end
	end,
}

Current = {
	Document = nil,
	TextInput = nil,
	CursorPos = {1,1},
	CursorColour = colours.black,
}

Events = {}

Button = {
	X = 1,
	Y = 1,
	Width = 0,
	Height = 0,
	BackgroundColour = colours.lightGrey,
	TextColour = colours.white,
	ActiveBackgroundColour = colours.lightGrey,
	Text = "",
	Parent = nil,
	_Click = nil,
	Toggle = nil,

	AbsolutePosition = function(self)
		return self.Parent:AbsolutePosition()
	end,

	Draw = function(self)
		local bg = self.BackgroundColour
		local tc = self.TextColour
		if type(bg) == 'function' then
			bg = bg()
		end

		if self.Toggle then
			tc = UIColours.MenuBarActive
			bg = self.ActiveBackgroundColour
		end

		local pos = GetAbsolutePosition(self)
		Drawing.DrawBlankArea(pos.X, pos.Y, self.Width, self.Height, bg)
		Drawing.DrawCharactersCenter(pos.X, pos.Y, self.Width, self.Height, self.Text, tc, bg)
	end,

	Initialise = function(self, x, y, width, height, backgroundColour, parent, click, text, textColour, toggle, activeBackgroundColour)
		local new = {}    -- the new instance
		setmetatable( new, {__index = self} )
		height = height or 1
		new.Width = width or #text + 2
		new.Height = height
		new.Y = y
		new.X = x
		new.Text = text or ""
		new.BackgroundColour = backgroundColour or colours.lightGrey
		new.TextColour = textColour or colours.white
		new.ActiveBackgroundColour = activeBackgroundColour or colours.lightGrey
		new.Parent = parent
		new._Click = click
		new.Toggle = toggle
		return new
	end,

	Click = function(self, side, x, y)
		if self._Click then
			if self:_Click(side, x, y, not self.Toggle) ~= false and self.Toggle ~= nil then
				self.Toggle = not self.Toggle
				Draw()
			end
			return true
		else
			return false
		end
	end
}

TextInput = {
	Value = "",
	Change = nil,
	CursorPos = nil,
	Numerical = false,

	Initialise = function(self, value, change, numerical)
		local new = {}    -- the new instance
		setmetatable( new, {__index = self} )
		new.Value = value
		new.Change = change
		new.CursorPos = #value
		new.Numerical = numerical
		return new
	end,

	Char = function(self, char)
		if self.Numerical then
			char = tostring(tonumber(char))
		end
		if char == 'nil' then
			return
		end
		self.Value = string.sub(self.Value, 1, self.CursorPos ) .. char .. string.sub( self.Value, self.CursorPos + 1 )
		
		self.CursorPos = self.CursorPos + 1
		self.Change(key)
	end,

	Key = function(self, key)
		if key == keys.enter then
			self.Value = string.sub(self.Value, 1, self.CursorPos ) .. '\n' .. string.sub( self.Value, self.CursorPos + 1 )
			self.Change(key)		
		elseif key == keys.left then
			-- Left
			if self.CursorPos > 0 then
				self.CursorPos = self.CursorPos - 1
				self.Change(key)
			end
			
		elseif key == keys.right then
			-- Right				
			if self.CursorPos < string.len(self.Value) then
				self.CursorPos = self.CursorPos + 1
				self.Change(key)
			end
		
		elseif key == keys.backspace then
			-- Backspace
			if self.CursorPos > 0 then
				self.Value = string.sub( self.Value, 1, self.CursorPos - 1 ) .. string.sub( self.Value, self.CursorPos + 1 )
				self.CursorPos = self.CursorPos - 1
			end
			self.Change(key)
		elseif key == keys.home then
			-- Home
			self.CursorPos = 0
			self.Change(key)
		elseif key == keys.delete then
			if self.CursorPos < string.len(self.Value) then
				self.Value = string.sub( self.Value, 1, self.CursorPos ) .. string.sub( self.Value, self.CursorPos + 2 )				
				self.Change(key)
			end
		elseif key == keys["end"] then
			-- End
			self.CursorPos = string.len(self.Value)
			self.Change(key)
		end
	end
}

Menu = {
	X = 0,
	Y = 0,
	Width = 0,
	Height = 0,
	Owner = nil,
	Items = {},
	RemoveTop = false,

	Draw = function(self)
		Drawing.DrawBlankArea(self.X + 1, self.Y + 1, self.Width, self.Height, UIColours.Shadow)
		if not self.RemoveTop then
			Drawing.DrawBlankArea(self.X, self.Y, self.Width, self.Height, UIColours.MenuBackground)
			for i, item in ipairs(self.Items) do
				if item.Separator then
					Drawing.DrawArea(self.X, self.Y + i, self.Width, 1, '-', colours.grey, UIColours.MenuBackground)
				else
					local textColour = UIColours.MenuText
					if (item.Enabled and type(item.Enabled) == 'function' and item.Enabled() == false) or item.Enabled == false then
						textColour = UIColours.MenuDisabledText
					end
					Drawing.DrawCharacters(self.X + 1, self.Y + i, item.Title, textColour, UIColours.MenuBackground)
				end
			end
		else
			Drawing.DrawBlankArea(self.X, self.Y, self.Width, self.Height, UIColours.MenuBackground)
			for i, item in ipairs(self.Items) do
				if item.Separator then
					Drawing.DrawArea(self.X, self.Y + i - 1, self.Width, 1, '-', colours.grey, UIColours.MenuBackground)
				else
					local textColour = UIColours.MenuText
					if (item.Enabled and type(item.Enabled) == 'function' and item.Enabled() == false) or item.Enabled == false then
						textColour = UIColours.MenuDisabledText
					end
					Drawing.DrawCharacters(self.X + 1, self.Y + i - 1, item.Title, textColour, UIColours.MenuBackground)

					Drawing.DrawCharacters(self.X - 1 + self.Width-#item.KeyName, self.Y + i - 1, item.KeyName, textColour, UIColours.MenuBackground)
				end
			end
		end
	end,

	NameForKey = function(self, key)
		if key == keys.leftCtrl then
			return '^'
		elseif key == keys.tab then
			return 'Tab'
		elseif key == keys.delete then
			return 'Delete'
		elseif key == keys.n then
			return 'N'
		elseif key == keys.s then
			return 'S'
		elseif key == keys.o then
			return 'O'
		elseif key == keys.z then
			return 'Z'
		elseif key == keys.y then
			return 'Y'
		elseif key == keys.c then
			return 'C'
		elseif key == keys.x then
			return 'X'
		elseif key == keys.v then
			return 'V'
		elseif key == keys.r then
			return 'R'
		elseif key == keys.l then
			return 'L'
		elseif key == keys.t then
			return 'T'
		elseif key == keys.h then
			return 'H'
		elseif key == keys.e then
			return 'E'
		elseif key == keys.p then
			return 'P'
		elseif key == keys.f then
			return 'F'
		elseif key == keys.m then
			return 'M'
		else
			return '?'		
		end
	end,

	Initialise = function(self, x, y, items, owner, removeTop)
		local new = {}    -- the new instance
		setmetatable( new, {__index = self} )
		if not owner then
			return
		end

		local keyNames = {}

		for i, v in ipairs(items) do
			items[i].KeyName = ''
			if v.Keys then
				for _i, key in ipairs(v.Keys) do
					items[i].KeyName = items[i].KeyName .. self:NameForKey(key)
				end
			end
			if items[i].KeyName ~= '' then
				table.insert(keyNames, items[i].KeyName)
			end
		end
		local keysLength = LongestString(keyNames)
		if keysLength > 0 then
			keysLength = keysLength + 2
		end

		new.Width = LongestString(items, 'Title') + 2 + keysLength
		if new.Width < 10 then
			new.Width = 10
		end
		new.Height = #items + 2
		new.RemoveTop = removeTop or false
		if removeTop then
			new.Height = new.Height - 1
		end
		
		if y < 1 then
			y = 1
		end
		if x < 1 then
			x = 1
		end

		if y + new.Height > Drawing.Screen.Height + 1 then
			y = Drawing.Screen.Height - new.Height
		end
		if x + new.Width > Drawing.Screen.Width + 1 then
			x = Drawing.Screen.Width - new.Width
		end


		new.Y = y
		new.X = x
		new.Items = items
		new.Owner = owner
		return new
	end,

	New = function(self, x, y, items, owner, removeTop)
		if Current.Menu and Current.Menu.Owner == owner then
			Current.Menu = nil
			return
		end

		local new = self:Initialise(x, y, items, owner, removeTop)
		Current.Menu = new
		return new
	end,

	Click = function(self, side, x, y)
		local i = y-1
		if self.RemoveTop then
			i = y
		end
		if i >= 1 and y < self.Height then
			if not ((self.Items[i].Enabled and type(self.Items[i].Enabled) == 'function' and self.Items[i].Enabled() == false) or self.Items[i].Enabled == false) and self.Items[i].Click then
				self.Items[i]:Click()
				if Current.Menu.Owner and Current.Menu.Owner.Toggle then
					Current.Menu.Owner.Toggle = false
				end
				Current.Menu = nil
				self = nil
			end
			return true
		end
	end
}

MenuBar = {
	X = 1,
	Y = 1,
	Width = Drawing.Screen.Width,
	Height = 1,
	MenuBarItems = {},

	AbsolutePosition = function(self)
		return {X = self.X, Y = self.Y}
	end,

	Draw = function(self)
		--Drawing.DrawArea(self.X - 1, self.Y, 1, self.Height, "|", UIColours.ToolbarText, UIColours.Background)

		Drawing.DrawBlankArea(self.X, self.Y, self.Width, self.Height, colours.grey)
		for i, button in ipairs(self.MenuBarItems) do
			button:Draw()
		end
	end,

	Initialise = function(self, items)
		local new = {}    -- the new instance
		setmetatable( new, {__index = self} )
		new.X = 1
		new.Y = 1
		new.MenuBarItems = items
		return new
	end,

	AddToolbarItem = function(self, item)
		table.insert(self.ToolbarItems, item)
		self:CalculateToolbarItemPositions()
	end,

	CalculateToolbarItemPositions = function(self)
		local currY = 1
		for i, toolbarItem in ipairs(self.ToolbarItems) do
			toolbarItem.Y = currY
			currY = currY + toolbarItem.Height
		end
	end,

	Click = function(self, side, x, y)
		for i, item in ipairs(self.MenuBarItems) do
			if item.X <= x and item.X + item.Width > x then
				if item:Click(item, side, x - item.X + 1, 1) then
					break
				end
			end
		end
		return false
	end
}

TextFormatPlainText = 1
TextFormatInkText = 2

Document = {
	X = 1,
	Y = 1,
	PageSize = {Width = 25, Height = 21},
	TextInput = nil,
	Pages = {},
	Format = TextFormatPlainText,
	Title = '',

	CalculateLineWrapping = function(self)
		local limit = self.PageSize.Width
		local text = self.TextInput.Value
        local lines = {''}
        for word, space in text:gmatch('(%S+)(%s*)') do
                local temp = lines[#lines] .. word .. space:gsub('\n','')
                if #temp > limit then
                    table.insert(lines, '')
                end
                if space:find('\n') then
                    lines[#lines] = lines[#lines] .. word
                    
                    space = space:gsub('\n', function()
                            table.insert(lines, '')
                            return ''
                    end)
                else
                    lines[#lines] = lines[#lines] .. word .. space
                end
                if #lines[#lines]>limit then
                	local _line = lines[#lines]
                	lines[#lines] = _line:sub(1,limit)
                	lines[#lines + 1] = _line:sub(limit+1)
                end
        end
        return lines
	end,

	CalculateCursorPos = function(self)
		local passedCharacters = 0
		Current.CursorPos = nil
		for i, page in ipairs(self.Pages) do
			page:Draw((i-1)*self.PageSize.Height + 1)
			if not Current.CursorPos then
				for i, line in ipairs(page.Lines) do
					if passedCharacters + #line.Text >= self.TextInput.CursorPos then
						Current.CursorPos = {self.X + page.MarginX + (self.TextInput.CursorPos - passedCharacters), 4 + i}
						break
					end
					passedCharacters = passedCharacters + #line.Text + 1
				end
			end
		end
	end,

	Draw = function(self)
		self:CalculatePages()
		self:CalculateCursorPos()
	end,

	CalculatePages = function(self)
		self.Pages = {}
		local lines = self:CalculateLineWrapping()
		local pageLines = {}
		for i, line in ipairs(lines) do
			if i % self.PageSize.Height == 0 then
				table.insert(self.Pages, Page:Initialise(self, pageLines))
				pageLines = {}
			end
			table.insert(pageLines, TextLine:Initialise(line))
		end
		if #pageLines ~= 0 then
			table.insert(self.Pages, Page:Initialise(self, pageLines))
		end
	end,

	Initialise = function(self, text, title)
		local new = {}    -- the new instance
		setmetatable( new, {__index = self} )
		new.Title = title or 'New Document'
		new.X = (Drawing.Screen.Width - (new.PageSize.Width + 2*(Page.MarginX)))/2
		new.Y = 3
		new.TextInput = TextInput:Initialise(text, function()
			Draw()
		end, false)
		Current.TextInput = new.TextInput
		return new
	end
}

AlignmentLeft = 1
AlignmentCentre = 2
AlignmentRight = 3

TextLine = {
	Text = "",
	Alignment = AlignmentLeft,

	Initialise = function(self, text, alignment)
		local new = {}    -- the new instance
		setmetatable( new, {__index = self} )
		new.Text = text
		new.Alignment = alignment or AlignmentLeft
		return new
	end
}

Page = {
	X = 1,
	Y = 1,
	Width = 1,
	Height = 1,
	MarginX = 3,
	MarginY = 2,
	BackgroundColour = colours.white,
	TextColour = colours.white,
	ActiveBackgroundColour = colours.lightGrey,
	Lines = {},
	Parent = nil,

	AbsolutePosition = function(self)
		return self.Parent:AbsolutePosition()
	end,

	Draw = function(self, y)
		local pos = GetAbsolutePosition(self)
		Drawing.DrawBlankArea(pos.X+self.Width,pos.Y -1 + y+1, 1, self.Height, UIColours.Shadow)
		Drawing.DrawBlankArea(pos.X+1, pos.Y -1 + y+self.Height, self.Width, 1, UIColours.Shadow)
		Drawing.DrawBlankArea(pos.X, pos.Y -1 + y, self.Width, self.Height, self.BackgroundColour)
		for i, line in ipairs(self.Lines) do
			Drawing.DrawCharacters(pos.X + self.MarginX, pos.Y -2 + y + i + self.MarginY, line.Text, self.TextColour, self.BackgroundColour)
		end
	end,

	Initialise = function(self, parent, lines)
		local new = {}    -- the new instance
		setmetatable( new, {__index = self} )
		new.Height = parent.PageSize.Height + 2 * self.MarginY
		new.Width = parent.PageSize.Width + 2 * self.MarginX
		new.X = 1
		new.Y = 1
		new.Lines = lines or {}
		new.BackgroundColour = colours.white
		new.TextColour = colours.black
		new.Parent = parent
		return new
	end,

	Click = function(self, side, x, y)
		if self._Click then
			Draw()
			return true
		else
			return false
		end
	end
}

function GetAbsolutePosition(object)
	local obj = object
	local i = 0
	local x = 1
	local y = 1
	while true do
		x = x + obj.X - 1
		y = y + obj.Y - 1

		if not obj.Parent then
			return {X = x, Y = y}
		end

		obj = obj.Parent

		if i > 32 then
			return {X = 1, Y = 1}
		end

		i = i + 1
	end

end

function Draw()
	if isDrawing then
		needsDraw = true
		return
	end
	needsDraw = false
	isDrawing = true

	if not Current.Window then
		Drawing.Clear(colours.lightGrey)
	else
		Drawing.DrawArea(1, 2, Drawing.Screen.Width, Drawing.Screen.Height, '|', colours.black, colours.lightGrey)
	end

	Current.Document:Draw()

	Current.MenuBar:Draw()

	if Current.Menu then
		Current.Menu:Draw()
	end

	if Current.Window then
		Current.Window:Draw()
	end

	Drawing.DrawBuffer()
	term.setCursorPos(2,2)
	print(Current.TextInput.CursorPos)
	if Current.TextInput and Current.CursorPos then
		term.setCursorPos(Current.CursorPos[1], Current.CursorPos[2])
		term.setCursorBlink(true)
		term.setTextColour(Current.CursorColour)
	else
		term.setCursorBlink(false)
	end

	isDrawing = false
	if needsDraw then
		Draw()
	end
end
MainDraw = Draw

LongestString = function(input, key)
	local length = 0
	for i = 1, #input do
		local value = input[i]
		if key then
			if value[key] then
				value = value[key]
			else
				value = ''
			end
		end
		local titleLength = string.len(value)
		if titleLength > length then
			length = titleLength
		end
	end
	return length
end

function LoadMenuBar()
	Current.MenuBar = MenuBar:Initialise({
		Button:Initialise(1, 1, nil, nil, colours.grey, Current.MenuBar, function(self, side, x, y, toggle)
			if toggle then
				Menu:New(1, 2, {
					{
						Title = "New...",
						Click = function()
							DisplayNewDocumentWindow()
						end,
						Keys = {
							keys.leftCtrl,
							keys.n
						}
					},
					{
						Title = 'Open...',
						Click = function()
							DisplayOpenDocumentWindow()
						end,
						Keys = {
							keys.leftCtrl,
							keys.o
						}
					},
					{
						Separator = true
					},
					{
						Title = 'Save...',
						Click = function()
							Current.Artboard:Save()
						end,
						Keys = {
							keys.leftCtrl,
							keys.s
						},
						Enabled = function()
							return true
						end
					},
					{
						Separator = true
					},
					{
						Title = 'Quit',
						Click = function()
							if Close() then
								OneOS.Close()
							end
						end
					},
			--[[
					{
						Title = 'Save As...',
						Click = function()

						end
					}	
			]]--
				}, self, true)
			else
				Current.Menu = nil
			end
			return true 
		end, 'File', colours.lightGrey, false),
		Button:Initialise(7, 1, nil, nil, colours.grey, Current.MenuBar, function(self, side, x, y, toggle)
			if not self.Toggle then
				Menu:New(7, 2, {
			--[[
					{
						Title = "Undo",
						Click = function()
						end,
						Keys = {
							keys.leftCtrl,
							keys.z
						},
						Enabled = function()
							return false
						end
					},
					{
						Title = 'Redo',
						Click = function()
							
						end,
						Keys = {
							keys.leftCtrl,
							keys.y
						},
						Enabled = function()
							return false
						end
					},
					{
						Separator = true
					},
			]]--
					{
						Title = 'Cut',
						Click = function()
							Clipboard.Cut(Current.Layer:PixelsInSelection(true), 'sketchpixels')
						end,
						Keys = {
							keys.leftCtrl,
							keys.x
						},
						Enabled = function()
							return Current.Selection and Current.Selection[1] and Current.Selection[2] ~= nil
						end
					},
					{
						Title = 'Copy',
						Click = function()
							Clipboard.Copy(Current.Layer:PixelsInSelection(), 'sketchpixels')
						end,
						Keys = {
							keys.leftCtrl,
							keys.c
						},
						Enabled = function()
							return Current.Selection and Current.Selection[1] and Current.Selection[2] ~= nil
						end
					},
					{
						Title = 'Paste',
						Click = function()
							Current.Layer:InsertPixels(Clipboard.Paste())
						end,
						Keys = {
							keys.leftCtrl,
							keys.v
						},
						Enabled = function()
							return (not Clipboard.isEmpty()) and Clipboard.Type == 'sketchpixels'
						end
					}
				}, self, true)
			else
				Current.Menu = nil
			end
			return true 
		end, 'Edit', colours.lightGrey, false)
	})
end

function Initialise(arg)
	if not OneOS then
		SplashScreen()
	end
	EventRegister('mouse_click', TryClick)
	EventRegister('mouse_drag', function(event, side, x, y)TryClick(event, side, x, y, true)end)
	EventRegister('mouse_scroll', Scroll)
	EventRegister('key', HandleKey)
	EventRegister('char', HandleKey)
	EventRegister('timer', Timer)
	EventRegister('terminate', function(event) if Close() then error( "Terminated", 0 ) end end)
	
	term.setBackgroundColour(colours.lightGrey)
	term.clear()

	LoadMenuBar()

	Current.Document = Document:Initialise('Hello everybody!')

	if OneOS then
		fs = OneOS.FS
	end
	--[[
if arg and fs.exists(arg) then
		OpenDocument(arg)
	else
		DisplayNewDocumentWindow()
	end
]]--

	Draw()

	EventHandler()
end


function HandleKey(...)
	local args = {...}
	local event = args[1]
	local keychar = args[2]
	if Current.TextInput then
		if event == 'char' then
			Current.TextInput:Char(keychar)
		elseif event == 'key' then
			Current.TextInput:Key(keychar)
		end
	elseif event == 'key' then
		--CheckKeyboardShortcut(keychar)
	end
end

--[[
	Check if the given object falls under the click coordinates
]]--
function CheckClick(object, x, y)
	if object.X <= x and object.Y <= y and object.X + object.Width > x and object.Y + object.Height > y then
		return true
	end
end

--[[
	Attempt to clicka given object
]]--
function DoClick(object, side, x, y, drag)
	if object and CheckClick(object, x, y) then
		return object:Click(side, x - object.X + 1, y - object.Y + 1, drag)
	end	
end

--[[
	Try to click at the given coordinates
]]--
function TryClick(event, side, x, y, drag)
	if Current.Menu then
		if DoClick(Current.Menu, side, x, y, drag) then
			Draw()
			return
		else
			if Current.Menu.Owner and Current.Menu.Owner.Toggle then
				Current.Menu.Owner.Toggle = false
			end
			Current.Menu = nil
			Draw()
			return
		end
	elseif Current.Window then
		if DoClick(Current.Window, side, x, y, drag) then
			Draw()
			return
		else
			Current.Window:Flash()
			return
		end
	end
	local interfaceElements = {}

	table.insert(interfaceElements, Current.MenuBar)

	for i, object in ipairs(interfaceElements) do
		if DoClick(object, side, x, y, drag) then
			Draw()
			return
		end		
	end
	Draw()
end

--[[
	Registers functions to run on certain events
]]--
function EventRegister(event, func)
	if not Events[event] then
		Events[event] = {}
	end

	table.insert(Events[event], func)
end

--[[
	The main loop event handler, runs registered event functinos
]]--
function EventHandler()
	while true do
		local event, arg1, arg2, arg3, arg4 = os.pullEventRaw()
		if Events[event] then
			for i, e in ipairs(Events[event]) do
				e(event, arg1, arg2, arg3, arg4)
			end
		end
	end
end

Initialise()